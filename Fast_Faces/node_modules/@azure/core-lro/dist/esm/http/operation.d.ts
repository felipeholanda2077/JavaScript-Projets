import { HttpOperationMode, LongRunningOperation, ResourceLocationConfig, OperationResponse, RawResponse } from "./models.js";
import { LroError, OperationConfig, OperationStatus, RestorableOperationState, StateProxy } from "../poller/models.js";
import { AbortSignalLike } from "@azure/abort-controller";
export declare function inferLroMode(rawResponse: RawResponse, resourceLocationConfig?: ResourceLocationConfig): (OperationConfig & {
    mode: HttpOperationMode;
}) | undefined;
export declare function parseRetryAfter<T>({ rawResponse }: OperationResponse<T>): number | undefined;
export declare function getErrorFromResponse<T>(response: OperationResponse<T>): LroError | undefined;
export declare function getStatusFromInitialResponse<TState>(inputs: {
    response: OperationResponse<unknown>;
    state: RestorableOperationState<TState>;
    operationLocation?: string;
}): OperationStatus;
export declare function getOperationLocation<TState>({ rawResponse }: OperationResponse, state: RestorableOperationState<TState>): string | undefined;
export declare function getOperationStatus<TState>({ rawResponse }: OperationResponse, state: RestorableOperationState<TState>): OperationStatus;
export declare function getResourceLocation<TState>(res: OperationResponse, state: RestorableOperationState<TState>): string | undefined;
export declare function isOperationError(e: Error): boolean;
/** Polls the long-running operation. */
export declare function pollHttpOperation<TState, TResult>(inputs: {
    lro: LongRunningOperation;
    stateProxy: StateProxy<TState, TResult>;
    processResult?: (result: unknown, state: TState) => TResult;
    updateState?: (state: TState, lastResponse: OperationResponse) => void;
    isDone?: (lastResponse: OperationResponse, state: TState) => boolean;
    setDelay: (intervalInMs: number) => void;
    options?: {
        abortSignal?: AbortSignalLike;
    };
    state: RestorableOperationState<TState>;
    setErrorAsResult: boolean;
}): Promise<void>;
//# sourceMappingURL=operation.d.ts.map